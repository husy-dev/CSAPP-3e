---
title: 【CSAPP】Ch8-异常控制流
date: 2018-03-24 11:24:40
tags:
- CSAPP
categories:
- CSAPP系列
---

## 总结
1. 我们的程序不可能不出错，一旦出错了就应当有处理措施。比如除零错误。
2. 很多行为是异步的无法预测的，比如我们什么时候会敲击键盘，什么时候网络数据到达。而我们的程序或者操作系统不可能一直等在那。因此我们还需要一个机制可以有效地处理这种异步信息。

这两个问题引出了这一章的重点：异常处理[^footnote]。

对于所有的异常，我们的机制是硬件负责改变处理器的状态码，软件负责告诉处理器应该怎么做。一般就是查表，硬件告诉软件出现的是哪一种异常，软件维护一个异常表，然后通过异常处理程序来处理这个异常。这个在unix系统里直接就叫做了中断向量表，而不是异常表[^footnote2]。

而上面的这种机制还非常底层，因为其实它需要利用硬件去响应，软件处理这种模式。还有一种更为高级的机制——信号。事实上，信号不是什么新产生的信息。而是底层的中断往上层应用程序的反馈。比如我们对进程的控制就是内核给进程发送一些信号，但在底层上实际上还是一些异常。只不过这些异常可能操作系统给了一些接口让应用程序去处理。

知识点其实就是两个，异常与信号。

1. 异常
    + 中断： 中断向量表，中断服务例程
    + 故障与终止
    + 系统调用：
        - 用户态与内核态的切换
        - 使得进程的概念成为可能： 控制进程（创建fork，加载，睡眠，结束exit），上下文切换，回收子进程（wait，waitpid)。
2. 信号
    + 发送信号：进程或者进程组
    + 接收信号：OS有自己的默认逻辑，可以通过signal函数自定义。
    + 阻塞与接触堵塞信号：显示和隐式
    + 信号处理程序： 异步安全，因为信号与主程序并发执行，共享全局变量；信号不排队特性。

## 笔记
1. 内核为每个进程都维护了pending向量和blocked向量，分别对应于待处理信号和被阻塞信号
> 信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的这一段时间；
信号的“阻塞”是一个开关动作，指的是阻止信号被处理，但不是阻止信 号产生。
信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了 防止信号打断敏感的操作。
参考[linux 信号阻塞和信号未决](https://blog.csdn.net/u012349696/article/details/50936585)

2. 异常与过程调用（也就是函数调用）的区别：
    + 过程调用在跳转之前会把返回地址压入栈中；而异常的返回地址则根据异常号的不同返回当前指令或者下一条指令的地址。
    + 异常还会额外地压入一些信息入栈
    + 异常的处理在一直在内核态，而过程调用在用户态。
2. 异常的类别
 ![异常类别](/Users/husy/Documents/CSAPP-3e/【CSAPP】Ch8-异常控制流.assets/image.png)
    + 注意这里的I/O设备不仅仅指输出的屏幕或者输入的键盘，包括网卡，时钟都算。
    + 然后中断是异步的原因是因为中断并不是由当前执行的某条指令产生的。也就是你无法获悉它在什么时候会发生。而同步的话都因为当前执行的某条指令产生的，是可与侧的。也就是再执行一遍，也会是在同样的地方产生异常。
3. Linux/X86-64异常的一些常识：
    + 有256种异常，前32种是Intel架构师定义的异常。因此堆任何x86-64的系统都是一样的。
    + 32～255都是系统定义的中断和陷阱。
    + 系统调用对应与一个异常里的一个号，它额外还有一个系统调用的表的偏移量。然后系统调用靠寄存器传递参数，而不是像函数调用一样用栈传递。规定是%rax存放系统调用号，比如60号是终止进程的系统调用，然后%rdi，%rsi等寄存器保存系统调用需要的参数。而返回值errono也在%rax中，而如果返回值是负数，就表明出错了。
3. 并行与并发
    + 并行更为严格。要求两个程序真正地同时运行在两个CPU上或者计算机上。而并发只需要时间上的重叠，就是X结束之前，Y开始运行了，我们就说X和Y是并发的。但是很有可能X和Y的指令是轮流在一个CPU上执行的。

4. fork
    + 子进程得到父进程用户级的虚拟地址空间的一份副本，包括代码，数据，堆和共享库以及用户栈。还获得与父进程一致的文件描述符。
    + 子进程的fork返回0
    + 注意，是数据独立，但是文件共享(描述符是独立的，但是描述符指向的打开文件表的表项是一样的，也就共享文件位置等。）
    + waitpid2.c这个程序里有一段：
    ```
    #define N 3 
    /* Parent creates N children */
        for (i = 0; i < N; i++) 
    	if ((pid[i] = Fork()) == 0)  /* Child */          //line:ecf:waitpid2:fork
    	    exit(100+i);
    ```
    一开始觉得当N=3时，难道不应该有8个线程吗？（见下图），如果这里在fork返回子进程时执行的是别的操作，那么就是8个进程。但其实，因为子进程直接exit了，也就是不再执行循环操作了。这是一个很好的方法，防止进程的子子孙孙作用。另外就是要记住这种控制子进程顺序的方式。
   ![fork流程图](/Users/husy/Documents/CSAPP-3e/【CSAPP】Ch8-异常控制流.assets/Screenshot from 2018-07-12 10-03-36.png)
5. 练习题8.4的答案有一个地方是错的，最后的Bye前面的数字应该是2，而不是1.因为这里输出的是子进程的退出状态。由exit(2)可知，应该是2.
![Screenshot from 2018-07-12 10-40-01.png-67.8kB](/Users/husy/Documents/CSAPP-3e/【CSAPP】Ch8-异常控制流.assets/Screenshot from 2018-07-12 10-40-01.png)
6. 练习题8.7 ，sleep被信号打断是会立即返回的，但是由于SIGINT的默认行为是终止进程，于是我们其实只需要让SIGINT的默认行为是什么都不做就行了。答案的写法是直接return（这里就涉及到[return和exit(0)的区别](https://zhidao.baidu.com/question/496700945433053244.html)。).还有要注意的是这里不能直接用SIG_IGN,因为这样一来就是让sleep程序直接忽略了这个信号。
7. 信号的特征:
    + 信号如果被阻塞，就不能被接收。而阻塞又分隐式和显式，隐式指正在处理的类型K信号会阻塞接下来的类型K信号，而显示是应用程序用sigprocmask函数等去直接处理。
    + 一个进程里发送了却没有接收的信号（待处理信号）同一类型永远只有一个（因为一个进程的pending位向量）对于每一个类型的待处理信号只会有一个bit的标记，也就是有或者没有。如果一个进程有了一个信号类型为k的待处理信号，那么任何接下来接收到的信号类型为k的信号都会被直接丢弃，而不是排队等候处理。
    + 信号的处理是可以被其它信号打断的，处理s信号的时候来了t信号，那么就中断当前s处理程序去处理t信号，返回的时候就继续执行s处理程序的下一条指令。
8. 信号的安全处理：
    + 在处理程序中只调用异步信号安全的函数（可重入或者不能被信号处理程序中断）
    + 保存和恢复errno
    + 阻止所有信号，保护对共享全局变量的访问。
    + 用volatile声明全局变量,告诉编译器不要缓存这个值使得这个值的更新能被及时知道。
    + sig\_atomic\_t来处理全局变量
9. 非本地跳转的两个用法是：允许一个深度嵌套的函数中立即返回到一个错误处理程序中去而不用说一个个的把调用栈解开。比如C++里的try catch机制；另一个用法就是控制信号处理程序的返回位置。一般来讲信号处理程序返回后程序就接着上次执行的下一条执行，但是用非本地跳转就可以让程序从任意别的地方开始执行。
1. 家庭作业8.19值得记住，通过for(int i=0;i<n;++i) fork();得到的线程数一共是2<sup>n</sup>个。
2. 另一个要注意的是做8.13和8.16都忘记了父子进程全局变量是复制的，不是共享的。只有打开的文件是共享的。但是主程序和信号处理程序是共享全局变量的。
3. csapp里有一个例子图8-36与图8-37，似乎就是把waitpid从if改为while，为什么就可以解决信号不排队导致的僵尸进程问题呢？
>开始同第一个程序运行的一样，创建3个子进程，第一个子进程最先终止，发出一个SIGCHLD信号，父进程第一次调用信号处理程序。信号处理程序执行到whlie语句条件中的waitpid时，会一直停止在这个while循环中直到父进程没有子进程为止。处理完第一个终止的子进程后，此时很有可能第二个子进程也早已经终止了(即使此时第二个子进程没有终止也没有关系，waitpid会挂起调用进程，阻塞于此，一直等待有子进程终止)，导致内核发送了第二个SIGCHLD信号给父进程，然后这个信号会成为待处理信号。虽然这个信号成为待处理信号，没有立即马上调用相应的信号处理程序来处理，但是第一个SIGCHLD调用的信号处理程序中的waitpid语句仍然会回收终止的第二个子进程。第三个子进程发出的SIGCHLD信号虽然会被抛弃，但是同样会被第一个SIGCHLD信号调用的信号处理程序中的waitpid回收。至此，三个子进程都被回收完了，于是当第一个SIGCHLD信号调用的信号处理程序中的waitpid语句检查到没有父进程后，返回-1，while循环终止，睡眠2秒钟后，第一个信号调用的信号处理程序结束。当控制从第一个信号调用的信号处理程序返回后，内核检测到待处理信号集合中还有一个SIGCHLD信号，也就是第二个子进程终止发出的信号。虽然第二个子进程早已经被回收了，但是父进程还是会调用信号处理程序，while语句中的条件测试显然会失败，于是第二个SIGCHLD调用的信号处理程序什么都没有做，只是睡眠了2秒种就返回了。而第三个SIGCHLD信号虽然连信号处理程序都没有调用，但是第三个子进程同样按照我们所希望的也被回收了。可以看到，子进程虽然都被正确回收了，但是都是通过第一个子进程调用的信号处理程序中的waitpid语句回收的。
参考[csapp读书笔记-signal处理(阻塞、排队、中断)](https://blog.csdn.net/qq_32400847/article/details/52101983)

那么这个处理方式就有一点点特殊性，但是大部分时候我们要处理的就是回收进程的信号不排队的问题。

## Todo
1. 家庭作业8.24\～8.26没有做。

[^footnote]: CSAPP里把所有都叫做异常，但我认为这样难以理解，因为一个键盘的敲击对OS还是应用程序在直观与字面意义上都不能异常，我认为把中断单独拿出来。但是如果站在更为抽象的层面上来讲，中断也好，异常也好，其实都是对当前程序顺序执行的一种破坏，使得它们要停下来去做一些别的事情。或者处理好这个异常，或者就直接退出了该程序。因此都归做异常也无可厚非。

[^footnote2]: 似乎在学习OS理论的时候只知道中断向量表，不知道异常表。是因为我们一般都是以x86的架构来学习的。而x86里没有区分这两者，都放在了中断向量表里。参考[异常向量表和中断向量表的区别](https://blog.csdn.net/selous/article/details/64983718)。另外要注意，系统调用在中断向量表里只有一个代号。