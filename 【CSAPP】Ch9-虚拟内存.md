---
title: 【CSAPP】Ch9-虚拟内存
date: 2018-03-24 11:25:24
tags:
- CSAPP
categories:
- CSAPP系列
---

## 总结
这一章主要讲了：
1. 虚拟地址如何转换成物理地址：页表，TLB，MMU等
2. 每一个进程都有自己的虚拟地址空间，其结构是怎样的：
3. ![内存空间结构](/Users/husy/Documents/CSAPP-3e/【CSAPP】Ch9-虚拟内存.assets/Screenshot from 2018-07-22 14-20-28.png)
4. 然后就是虚拟地址的角色：
+ 充当磁盘的缓存，包括页面置换算法等
+ 充当进程的保护： 页表有检查内存访问合法性的功能等
+ 充当内存管理的工具
5. 应用程序使用内存的两种方式：
+ 内存映射
+ 动态分配，包括垃圾回收机制。

## 问题思考
2. 9.6.4的综合问题：
    + 页表条目的个数取决于虚拟地址(而不是物理地址)的长度和页表的大小，所以这里页表是2<sup>6</sup>，而虚拟地址的长度是14，所以 # PTE = 2<sup>8</sup> 
 - TLB是虚拟地址来寻址的，而L1等SRAM的缓存是通过物理地址来寻址的。
 - 顺一下CPU访问0x03d4处字节的过程：
    1. 将该地址传送到MMU
    2. MMU在TLB里查找（因为虚拟地址是14位）因此，查找的是：00 0011 1101 0100
    3. （因为TLB是四路组相联，一共有16个条目），那么VPN的前2个低位作为组索引。（因为页的大小是2<sup>6</sup>，因此VPO的长度是虚拟地址的前6位。那么剩下的6位就是标记位。那么我们在TLB表中找到第11（也就是3）组的标记位为000011（也就是3）的表项，获取它存的ppn——0D。
    4. 然后剩下低6位010100作为VPO，也就是PPO，在MMU组成物理地址00 1101 010100，也就是0x354.
    5. 然后因为高缓是直接映射，有16个组，那么组索引的长度就是4个位，然后因为PPO和VPO一致，那么就是低2位是缓存偏移，紧接着4位是组索引，最后6位是标记。于是我们在高缓里找到第0101（也就是0x5）组的行，先看有效位是不是1，再对比其标记是不是0xd。缓存命中，取出0x36的数据。**要注意：**是先返回给MMU，然后MMU再返回给CPU，而不是直接给了CPU。

2. 内存映射
    + 这其实和加载差不多，linux提供了mmap方法。c标准库里提供了malloc等方法。
3. 动态内存分配器
```C
    #include <stdlib.h>
    void *malloc(size_t n);
    void free(void *ptr);
```

+ malloc返回的指针是指向一个大小**至少**为n的内存块，这个内存块要对可能包含的任何数据对象类型做对齐。比如32位的编译就返回8的倍数的地址，64位编译就返回16位的倍数的地址。
+ free是不会返回任何信息的，所以释放成功与否是不确定的。
4. 分配器的要求：
    + 立即回应请求，不允许缓存或者重新排列。
    + 只能使用堆，任何非标量数据结构都在堆里
    + 内存对齐
    + 不能修改已分配的块
5. 练习题9.6
    + 首先要知道内存对齐是指OS在分配资源时的要求，而分配器的块是包含了头部，有效载荷和有可能的填充部分的整体。
    + 其次块的头部里的块大小是指整个块的大小，而不是指有效载荷（也就是用户程序需要的大小）。
    + 这个例子里说内存对齐要求的是分配的块要是8的倍数。也就是其余部分和头部的4字节要组成8的倍数字节。因此最后一个malloc(13)，也就是分配13字节加上头部的4字节，那么OS一共要分配17字节，由于要是8的倍数，那就只能分配24字节了，也就是剩下7个字节作填充。
6. 练习题9.8
首先是一些宏需要理解，因为平时不怎么使用。
```C
    #define GET(p)       (*(unsigned int *)(p))
    #define GET_SIZE(p)  (GET(p) & ~0x7)
    #define GET_ALLOC(p) (GET(p) & 0x1) 
    #define HDRP(bp)       ((char *)(bp) - WSIZE)
    #define NEXT_BLKP(bp)  ((char *)(bp) + GET_SIZE(((char *)(bp) - WSIZE))) //line:vm:mm:nextblkp
    #define PREV_BLKP(bp)  ((char *)(bp) - GET_SIZE(((char *)(bp) - DSIZE))) 
```

+ 这里的GET(p)只是为了让后面void*的强制类型格式转换比较方便，并没有任何操作。
+ GET\_SIZE的功能是将头部变成块大小，因为头部的后三位是用来标记是否分配的，所以我们并上0x 1111 1111 1111 1111 1111 1111 1111 1000（也就是\~0x7, 至于为什么要取个反再与);
+ GET\_ALLOC则是与0x1的与，是因为它是用来将检测当前的块的头部是否最后一位是否是1，也就p指向的头部是否已经分配了。
+ HDRP是获取当前块的头部，参数bp永远是指向当前分配的块的留给用户程序使用的内存的第一个字节，所以它的前面就是头部；而头部的大小都是WSIZE，因此bp往前移WSIZE步就是指向头部的地址了。
+ FTRP是获取当前块的脚部，就是将当前的bp往后移这个内存块的大小。为什么要减去DWSIZE是因为首先我们的起点不是这个内存块的起点，而是跳过了头部的起点，这里就要减去一个WSIZE；另外我们不是要指向下一个块的开头，而是要指向上一个块的结尾，由于脚部也是一个WSIZE，所以又要减去一个WSIZE。
+ NEXT_BLKP(bp)返回的是指向下一个块的指针。逻辑是先读取当前块的头部，然后得到头部里存储的当前块的大小，然后指针再往后走这个多大小，就指向了下一块的有效载荷的第一位。你会疑惑，为什么不是指向下一块的头部？首先因为我们的块的大小指的是整个实际的内存块的大小（包括头部，有效载荷和填充位），于是当前的头部和下一个块的头部抵消，自然就指向了下一个块的有效载荷的第一个位置。因为块大小是包括了头部的。
+ 类似的，PREV_BLKP(bp)是往前走双字，因为想要获取上一个块的脚部，也就是获取上一块的大小。

于是，find\_fit的逻辑就很好懂，heap\_listp指向的是整个堆内存的第一个块，然后不断地获取下一个块，只要下一个块未分配并且大小比用户程序实际需要的内存大，就返回指向这个块的指针。否则就返回NULL。那么就来看一下整个程序如何保证这几个功能的实现的：
+ 维护heap\_listp： 首先一开始就定义全局变量——static char \*heap\_listp = 0; 然后在mm\_malloc函数里判断如果 \*heap\_listp = 0就调用mm\_init函数。而在mm\_init就初始化了\*heap\_listp，另起指向第一个块。而在后续的过程里，都没有改变过这个值。
+ 而这些块的头部是哪里来的呢？观察到mm\_init里还调用了mem\_sbrk和extend\_heap两个函数，不妨来看一下。
+ mem\_sbrk的作用是在预设的堆内存里申请多一点的空间，逻辑就是先检查一下申请的合法性（是否是正的，是否超过了预设堆内存的最大值），然后更新全局变量brk，返回旧的brk值。
+ extend\_heap这里的逻辑就是先把要申请的size内存对齐一下，然后用mem_sbrk申请，然后把申请的这一块的头部和脚部设置好，然后又新设置一个epilogue header结尾块。
只要把开头
7. 练习题9.9
    有一个要说明的是为什么这里判断要不要分割的条件是原始内存块与申请内存块大小之差是2个DSIZE？因为我们是DSIZE对齐，并且不允许有效载荷为0，由于头部和脚部加起来要占用一个DSIZE，因此最小的内存块大小就是2*DSIZE。

## 问题
1. 在9.8的内存映射里说的交换文件以及交换空间都限制着当前进程能够分配的虚拟页面的总数？
2. 9.8.3讲execve函数的时候说加载a.out的第一步就是删除已存在的用户区域，这是哪个区域？删除的是什么？
3. 所谓的对齐具体一点，为什么32位的编译就返回8的倍数的地址，64位编译就返回16位的倍数的地址？
4. 显示空闲链表里的空闲块排序顺序为什么影响释放一个块的时间？

## 家庭作业
家庭作业没做