---
title: 【CSAPP】Ch12-并发编程
date: 2018-03-27 23:16:11
tags:
- CSAPP
- 并发
categories:
- CSAPP系列
---

## 笔记
1. IPC机制（进程间的通信）
+ 信号是基本的IPC机制
+ 套接字接口是另一种形式
+ 管道
+ 先进先出
+ 系统V共享内存
+ 系统V信号量

2. I/O多路复用技术
+ 基本内容就是select函数。这个的思想就是，如果我们同时有多个端口要监听呢？比如我一个服务器同时要等待客户端的连接，又要等待来自自己标准输入的数据。那么我们就可以将accept替换成select。select维护一个读的数据集，从而可以同时管理多个文件描述符的读。写也一样。
+ 有一个缺点就是，select没有使用fork来创建进程，那么一个拿上面的例子来说，一旦它连接到某个客户端就会连续会送输入行，那么这个时间里你在服务器的标准输入端输入数据你是得不到响应的。解决的方式可以是用更细粒度的多重复用，比如连接后服务器只处理一次输入行的回送。
+ 事件驱动，将逻辑流模型转化位状态机。

3. 线程
+ [ ] 书上说线程由内核调度，但应该是取决于OS吧？
+ 每个进程有自己上下文，包括TID，栈，栈指针，程序计数器，通用寄存器和条件码。但是同一个进程里的线程共享整个进程的虚拟空间（包括只读文本，也就是代码，数据，读/写数据，堆和所有共享代码库，也共享打开的文件集合）
+ 与进程不同的是：它不遵循进程的父子层次关系来组织的，它们彼此是对等的关系。而所谓的主线程不过是第一个执行的而已。我们之前看到子进程是很难操纵父进程的，但是这里对等进程是可以彼此控制的。
+ Posix线程(Pthreads)是在C程序中处理线程的一个标准接口。可以看到线程的代码和数据都被封装在一个线程例程(thread routine)里
+ 对于示例代码里的echoservert.c里存在的问题，由于创建了线程以后是并发执行的，所以我们并不知道它和主线程谁接着执行。那么由于创建的线程里有一个是指针赋值，而这个指针只有一个，很有可能这个指针已经指向了下一个连接了，创建的线程才完成赋值。那么有一个连接就丢失了。所以我们这里要把这个accept返回的指针要独立开来。

4. 变量,[示例代码](http://csapp.cs.cmu.edu/3e/ics3/code/conc/sharing.c)
![img](/Users/husy/Documents/CSAPP-3e/【CSAPP】Ch12-并发编程.assets/Screenshot from 2018-07-13 20-42-16.png)

5. 并发错误
+ 进度图
![img](http://static.zybuluo.com/Husy/qyw4lwnfa6ou5leftjga69mj/Screenshot%20from%202018-07-13%2020-49-21.png)

6. 信号量->互斥访问
+ P(s)检测s是非零的就减一，然后立即返回；如果s是0，就挂起当前的进程。这个检测和减一是院子的，不能被打断的。 V(s)将s加一，然后重启被P操作阻塞的进程。但是这个重启的顺序不确定。
+ 基本思想就是把共享变量和这个s联系起来。一些名词是：
![img](http://static.zybuluo.com/Husy/f07kn5rl9q7yjp569aqbth6f/Screenshot%20from%202018-07-13%2021-22-20.png)

## 问题
1. 多线程服务器里传递Accpet返回的描述符，然后再将这个描述符给线程创建的函数。这里是通过指针来传递的，但是描述符不过是一个int，为什么也要用指针呢？我想是因为它虽然类型是一个int，但是它的存储位置等还是很有关系的，不然为什么会是一个描述符而不是一个简单的数据呢？

2. c语言里的static，全局变量，extern这些关键字还是没有搞清楚。static的变量究竟是放在哪里的？栈里吗？

## 家庭作业